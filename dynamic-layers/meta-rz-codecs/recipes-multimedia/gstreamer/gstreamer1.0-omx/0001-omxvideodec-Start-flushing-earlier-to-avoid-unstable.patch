From 845277cdf8def4fb816778f0746c679ee0c8451c Mon Sep 17 00:00:00 2001
From: Takuro Ashie <ashie@clear-code.com>
Date: Mon, 9 Dec 2024 13:03:02 +0900
Subject: [PATCH] omxvideodec: Start flushing earlier to avoid unstable
 behavior

Upstream-Status: Pending

Signed-off-by: Takuro Ashie <ashie@clear-code.com>
Signed-off-by: Kentaro Hayashi <hayashi@clear-code.com>
---
 omx/gstomxvideodec.c | 57 ++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 57 insertions(+)

diff --git a/omx/gstomxvideodec.c b/omx/gstomxvideodec.c
index e8e4ef0..8fbe4e8 100644
--- a/omx/gstomxvideodec.c
+++ b/omx/gstomxvideodec.c
@@ -73,6 +73,8 @@ static gboolean gst_omx_video_dec_stop (GstVideoDecoder * decoder);
 static gboolean gst_omx_video_dec_set_format (GstVideoDecoder * decoder,
     GstVideoCodecState * state);
 static gboolean gst_omx_video_dec_flush (GstVideoDecoder * decoder);
+static gboolean gst_omx_video_dec_sink_event (GstVideoDecoder * decoder,
+    GstEvent * event);
 static GstFlowReturn gst_omx_video_dec_handle_frame (GstVideoDecoder * decoder,
     GstVideoCodecFrame * frame);
 static GstFlowReturn gst_omx_video_dec_finish (GstVideoDecoder * decoder);
@@ -322,6 +324,7 @@ gst_omx_video_dec_class_init (GstOMXVideoDecClass * klass)
   video_decoder_class->start = GST_DEBUG_FUNCPTR (gst_omx_video_dec_start);
   video_decoder_class->stop = GST_DEBUG_FUNCPTR (gst_omx_video_dec_stop);
   video_decoder_class->flush = GST_DEBUG_FUNCPTR (gst_omx_video_dec_flush);
+  video_decoder_class->sink_event = GST_DEBUG_FUNCPTR (gst_omx_video_dec_sink_event);
   video_decoder_class->set_format =
       GST_DEBUG_FUNCPTR (gst_omx_video_dec_set_format);
   video_decoder_class->handle_frame =
@@ -3599,6 +3602,60 @@ gst_omx_video_dec_flush (GstVideoDecoder * decoder)
   return TRUE;
 }
 
+static gboolean
+gst_omx_video_dec_sink_event (GstVideoDecoder * decoder, GstEvent * event)
+{
+  GstOMXVideoDec *self;
+
+  self = GST_OMX_VIDEO_DEC (decoder);
+
+  switch (GST_EVENT_TYPE (event)) {
+  case GST_EVENT_FLUSH_START:
+    /* Although gst_omx_video_dec_flush() will be called in FLUSH_STOP event,
+       start flushing earlier to make sure to flush. */
+
+    GST_DEBUG_OBJECT(self, "flush_start");
+
+    /* 0) Pause the components */
+    if (gst_omx_component_get_state (self->dec, 0) == OMX_StateExecuting) {
+      gst_omx_component_set_state (self->dec, OMX_StatePause);
+      gst_omx_component_get_state (self->dec, GST_CLOCK_TIME_NONE);
+    }
+#if defined (USE_OMX_TARGET_RPI) && defined (HAVE_GST_GL)
+    if (self->eglimage) {
+      if (gst_omx_component_get_state (self->egl_render, 0) == OMX_StateExecuting) {
+	gst_omx_component_set_state (self->egl_render, OMX_StatePause);
+	gst_omx_component_get_state (self->egl_render, GST_CLOCK_TIME_NONE);
+      }
+    }
+#endif
+
+    /* 1) Flush the ports */
+    if (self->dec_in_port)
+      gst_omx_port_set_flushing (self->dec_in_port, 5 * GST_SECOND, TRUE);
+    if (self->dec_out_port)
+      gst_omx_port_set_flushing (self->dec_out_port, 5 * GST_SECOND, TRUE);
+#if defined (USE_OMX_TARGET_RPI) && defined (HAVE_GST_GL)
+    if (self->egl_in_port)
+      gst_omx_port_set_flushing (self->egl_in_port, 5 * GST_SECOND, TRUE);
+    if (self->egl_out_port)
+      gst_omx_port_set_flushing (self->egl_out_port, 5 * GST_SECOND, TRUE);
+#endif
+
+    GST_VIDEO_DECODER_CLASS
+      (gst_omx_video_dec_parent_class)->sink_event (decoder, event);
+    return TRUE;
+  case GST_EVENT_FLUSH_STOP:
+    /* gst_omx_video_dec_flush() will be called in parent sink_event(),
+       no need to finish flushing here. */
+    break;
+  default:
+    break;
+  }
+  return GST_VIDEO_DECODER_CLASS
+    (gst_omx_video_dec_parent_class)->sink_event (decoder, event);
+}
+
 static GstFlowReturn
 gst_omx_video_dec_handle_frame (GstVideoDecoder * decoder,
     GstVideoCodecFrame * frame)
-- 
2.43.0

